---
layout: post
title: 基于 Promise 的异步代码
author: xszhi
categories: tech-note
tags: [async, co, generator, promise, es6]
---

about getting rid of callback hell and implementation of more elegant async flow control with Promise, generator, co and async/await

<!-- more -->

# javascript async code optimization

打 js 代码过程中的大量异步操作和回调是个让人万分痛苦的事情，掉到这个坑里之后看自己的代码都会让人感到十分不安。为了让异步代码得到优化，出现了很多优秀的解决方案，其中最为炙手可热的包括 Promise, bluebird, Q, thunk, generator, co, async/await，以下对相应形式的代码组织进行简要介绍。Promise 和 thunk 两种 lazy evaluation 的实现成为了异步代码优化的基础，由于不久的某一天可能 co 的 yieldable 就不支持 thunk 了，且 Promise 的应用较 thunk 本身也更为广泛，本文只以 Promise 为基础进行介绍。如果想要系统了解 Promise 建议直接跳 [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)，在对 Promise 有了清晰的认识之后本文将对 es5 背景下对 Promise 的应用较有开创性的库进行介绍，以 bluebird 为主。在对 Promise 的原理，应用与不足熟悉之后本文将会对 es6 引入的 generator 进行介绍，generator 与相应的实例 runner 将异步流程带入了一个新的篇章，而 async/await 可以看作 generator 控制的一种语法糖，用 async 替换了 * 用 await 替换了 yield 使语意更为清晰，同时在语言内置了 runner 减少了与流程无关的代码。

## index

1. [Promise](#promise)
2. [bluebird/Q](#bluebird/Q)
3. [generator](#generator)
4. [co](#co)
5. [async/await](#async/await)


## Promise

Promise 和 thunk 两种 lazy evaluation 的实现成为了异步代码优化的基础，由于不久的某一天可能 co 的 yieldable 就不支持 thunk 了，且 Promise 的应用较 thunk 本身也更为广泛，本文只以 Promise 为基础进行介绍。

Promise 是一种用于异步操作的对象，一个 Promise 实例代表一种在代码执行时并不能得知结果的操作，但是操作的结果会在将来 Promise 内的操作完成后返回。当一个 Promise 被实例化以后它一定处于以下三种状态之一：

- pending: 初始状态，没有完成也没有被拒绝
- fulfilled: 意味着操作成功完成
- rejected: 操作失败

一个 pending 的 Promise 会根据操作的执行情况最终转化为 fulfilled 或者 rejected 且不可逆。

在 es6 中 Promise 是一个全局的构造函数，Promise 构造函数的原型方法和构造方法都会返回 Promise 实例，所以 Promise 是非常方便链式调用的。


```js
new Promise(/* executor */ function (resolv, reject) { ... });
Promise.resolve(value | Promsie | thenable);
Promise.reject(reason);
Promise.then(onFulfilled, onRejected);
Promise.catch(onRejected);
Promise.all(iterable);
Promise.race(iterable);
```

当一个 Promise 产生之后他就进入了 pending 状态，直到内部操作遇到 resolve 或是 reject 该 Promise 状态改变并将 value 或是 reason 传入 `onFulfilled` 和 `onRejected`, 这两个操作由实例的原型方法 then 或是 catch 传入。由于 then 方法和 catch 方法都返回 Promise 对象（具体的返回规则见下文）。所以在 Promise 的使用过程中链式调用是相当容易的，因而为连续的异步流程控制提供了一种解决方案。

```js
Promise.resolve([1, 2, 3])
.then((arr) => {
    console.log('in then 1', arr)
    return Promise.resolve(arr.map((num) => num * num))
})
.then((arr) => {
    console.log('in then 2', arr)
    throw new Error('make an error')
})
.catch((e) => {
    console.log('in catch 1', e)
    return Promise.reject('another error')
})
.catch((e) => {
    console.log('in catch 2', e)
    return Promise.resolve("let's make this to then method")
})
.then((msg) => {
    console.log('in then 3', msg)
})

// in then 1 [1, 2, 3]
// in then 2 [1, 4, 9]
// in catch 1 Error: make an error(…)
// in catch 2 another error
// in then 3 let's make this to then method
```

在 then 和 catch 方法中返回值会被转化为 Promise 实例，Error 类以外的值会被直接 resolve 而被  throw 的 Error 类的值将会被 Promise.reject  返回。

```js
Promise.resolve([1, 2, 3])
.then((result) => {
    console.log('in then 1', result)
    throw new Error('make an error')
})
.catch((e) => {
    console.log('in catch 2', e)
    return 'let us make some promise'
})
.then((msg) => {
    console.log('in then 2', msg)
})

// in then 1 [1, 2, 3]
// in catch 1 Error: make an error(…)
// in then 2 let us make some promise
```

以上是整个 Promise 的流程。以下接住一个 页面 dialog 与 ajax 请求的例子进行说明。 dialog: 需要设计一个在点击后能够更具 确认／取消 情况执行异步操作的对象。 ajax: 以 `$.ajax()` 为例。

```js
/*!
 * 传统的 Dialog 写法，为了节省篇幅此处只提供 Dialog 的调用模式
 * 场景 弹出 Dialog 等待用户确认，如果确认进行 ajax 请求，如果成功页面跳转。
 */

// 传统回调版本代码
new Dialog({
    id: 'someDialog',
    content: {
        desc: '是否确认跳转',
        confirm: '确认',
        cancel:  '取消'
    },
    confirm: function () {
        $.ajax({
            url: 'some/webapi'
            success: function (res) {
                if (res.status >= 200 && res.status <= 300) {
                    window.href = window.host + 'another/route'
                }
                else {
                    Dialog.close('someDialog')
                }
            },
            fail: function (e) {
                Dialog.contentChange({
                    id: 'someDialog',
                    content: ...
                })
                Dialog.close()
            }
        })
    },
    cancel: function () {
        somePageData = ''
        Dialog.close('someDialog')
    }
})

// Promise 版本代码
new Dialog({
    id: 'someDialog',
    content: {
        desc: '是否确认跳转',
        confirm: '确认',
        cancel:  '取消'
    }
}).init()
.then(function (clicked) {
    if (clicked === 'confirm') {
        // 之后的代码将会提供如何改造 $.ajax
        return Promise.resolve(asyncGet('some/webapi'))
    }
    else {
        somePageData = ''
        Dialog.close('someDialog')
    }
})
.then(function (res) {
    if (res.status >= 200 && res.status <= 300) {
        window.href = window.host + 'another/route'
    }
    else {
        Dialog.close('someDialog')
    }
})
.catch(function (e) {
    Dialog.contentChange({
        id: 'someDialog',
        content: ...
    })
    Dialog.close()
})
```

改造 $.ajax 以 get 方法为例，读者们可以附带研究一下 Promise 的构造函数的调用方式，关于 Promise 的各种重要方法请参见 [推荐阅读](#recommending-reading)，在此特别感谢 mdn 提供关于 Promise 的清晰讲解。

```js
function asyncGet (url) {
    return new Promise (resolve, reject) {
        $.get({
            url: url,
            success: function (data) {
                resolve(data)
            },
            error: function (e) {
                reject(e)
            }
        })
    }
}
```

在使用 Promsie 改造代码以后比较明显的好处是 1. 代码的组织更接近与操作的实际流程； 2. 金字塔显然是没有普通的异步深了。不过 `.then` 和 `.catch` 这个机制明显还是存在一定的无关代码。
在了解了 Promise 的基本使用之后， all 和 race 两种方法为流程控制提供了更多的可能性。 `all` 可以并发执行一系列 Promise 并在所有 Promise resolve 后将结果以数组的形式返回，可谓异步的 map；在错误处理方面，当这些 Promise 有任意一个 reject 后，错误将会抛出同时终止这一系列的 Promise 操作。而错误也可以统一处理减少了很多的重复代码。 `race` 方法与 `all` 的编写机制类似，但是 race 的核心流程却有很大差异， 对于这一系列 Promise 首先返回的操作将被传入后续操作，而其他的 Promise 操作随即停止。在 Promise 的最后，还是强烈推荐大家阅读以下文章。

### recommending reading

1. [Promise()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
2. [Promise.prototype.then()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)
3. [Promise.prototype.catch()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch)
4. [Promise.resolve()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
5. [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
